
# IMPORTING PACKAGES
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import requests
import datetime
from math import floor
from termcolor import colored as cl
from datetime import datetime, timedelta
import yfinance as yf
plt.style.use('fivethirtyeight')
plt.rcParams['figure.figsize'] = (20,10)


# EXTRACTING DATA
# Daten abrufen
end_date = datetime.now()
start_date = end_date - timedelta(days=965)
tsla = yf.Ticker("TSLA")
tsla = tsla.history(start=start_date, end=end_date)
print(tsla)
# SUPERTREND CALCULATION
def get_supertrend(High, Low, Close, lookback, multiplier):
    
    # ATR
    
    tr1 = pd.DataFrame(High - Low)
    tr2 = pd.DataFrame(abs(High - Close.shift(1)))
    tr3 = pd.DataFrame(abs(Low - Close.shift(1)))
    frames = [tr1, tr2, tr3]
    tr = pd.concat(frames, axis = 1, join = 'inner').max(axis = 1)
    atr = tr.ewm(lookback).mean()
    
    # H/L AVG AND BASIC UPPER & LOWER BAND
    
    hl_avg = (High + Low) / 2
    upper_band = (hl_avg + multiplier * atr).dropna()
    lower_band = (hl_avg - multiplier * atr).dropna()
    
    # FINAL UPPER BAND
    
    final_bands = pd.DataFrame(columns = ['upper', 'lower'])
    final_bands.iloc[:,0] = [x for x in upper_band - upper_band]
    final_bands.iloc[:,1] = final_bands.iloc[:,0]
    
    for i in range(len(final_bands)):
        if i == 0:
            final_bands.iloc[i,0] = 0
        else:
            if (upper_band.iloc[i] < final_bands.iloc[i-1,0]) | (Close.iloc[i-1] > final_bands.iloc[i-1,0]):
                final_bands.iloc[i,0] = upper_band.iloc[i]
            else:
                final_bands.iloc[i,0] = final_bands.iloc[i-1,0]
    
    # FINAL LOWER BAND
    
    for i in range(len(final_bands)):
        if i == 0:
            final_bands.iloc[i, 1] = 0
        else:
            if (lower_band.iloc[i] > final_bands.iloc[i-1,1]) | (Close.iloc[i-1] < final_bands.iloc[i-1,1]):
                final_bands.iloc[i,1] = lower_band.iloc[i]
            else:
                final_bands.iloc[i,1] = final_bands.iloc[i-1,1]
    
    # SUPERTREND
    
    supertrend = pd.DataFrame(columns = [f'supertrend_{lookback}'])
    supertrend.iloc[:,0] = [x for x in final_bands['upper'] - final_bands['upper']]
    
    for i in range(len(supertrend)):
        if i == 0:
            supertrend.iloc[i, 0] = 0
        elif supertrend.iloc[i-1, 0] == final_bands.iloc[i-1, 0] and Close.iloc[i] < final_bands.iloc[i, 0]:
            supertrend.iloc[i, 0] = final_bands.iloc[i, 0]
        elif supertrend.iloc[i-1, 0] == final_bands.iloc[i-1, 0] and Close.iloc[i] > final_bands.iloc[i, 0]:
            supertrend.iloc[i, 0] = final_bands.iloc[i, 1]
        elif supertrend.iloc[i-1, 0] == final_bands.iloc[i-1, 1] and Close.iloc[i] > final_bands.iloc[i, 1]:
            supertrend.iloc[i, 0] = final_bands.iloc[i, 1]
        elif supertrend.iloc[i-1, 0] == final_bands.iloc[i-1, 1] and Close.iloc[i] < final_bands.iloc[i, 1]:
            supertrend.iloc[i, 0] = final_bands.iloc[i, 0]
    
    supertrend = supertrend.set_index(upper_band.index)
    supertrend = supertrend.dropna()[1:]
    
    # ST UPTREND/DOWNTREND
    
    upt = []
    dt = []
    Close = Close.iloc[len(Close) - len(supertrend):]

    for i in range(len(supertrend)):
        if Close.iloc[i] > supertrend.iloc[i, 0]:
            upt.append(supertrend.iloc[i, 0])
            dt.append(np.nan)
        elif Close.iloc[i] < supertrend.iloc[i, 0]:
            upt.append(np.nan)
            dt.append(supertrend.iloc[i, 0])
        else:
            upt.append(np.nan)
            dt.append(np.nan)
            
    st, upt, dt = pd.Series(supertrend.iloc[:, 0]), pd.Series(upt), pd.Series(dt)
    upt.index, dt.index = supertrend.index, supertrend.index
    
    return st, upt, dt

tsla['st'], tsla['s_upt'], tsla['st_dt'] = get_supertrend(tsla['High'], tsla['Low'], tsla['Close'], 10, 3)
tsla = tsla[1:]
print(tsla.head())

# SUPERTREND PLOT

plt.plot(tsla['Close'], linewidth = 2, label = 'CLOSING PRICE')
plt.plot(tsla['st'], color = 'green', linewidth = 2, label = 'ST UPTREND 10,3')
plt.plot(tsla['st_dt'], color = 'r', linewidth = 2, label = 'ST DOWNTREND 10,3')
plt.legend(loc = 'upper left')
plt.show()

# SUPERTREND STRATEGY

def implement_st_strategy(prices, st):
    buy_price = []
    sell_price = []
    st_signal = []
    signal = 0
    
    for i in range(len(st)):
        if st.iloc[i-1] > prices.iloc[i-1] and st.iloc[i] < prices.iloc[i]:
            if signal != 1:
                buy_price.append(prices.iloc[i])
                sell_price.append(np.nan)
                signal = 1
                st_signal.append(signal)
            else:
                buy_price.append(np.nan)
                sell_price.append(np.nan)
                st_signal.append(0)
        elif st.iloc[i-1] < prices.iloc[i-1] and st.iloc[i] > prices.iloc[i]:
            if signal != -1:
                buy_price.append(np.nan)
                sell_price.append(prices.iloc[i])
                signal = -1
                st_signal.append(signal)
            else:
                buy_price.append(np.nan)
                sell_price.append(np.nan)
                st_signal.append(0)
        else:
            buy_price.append(np.nan)
            sell_price.append(np.nan)
            st_signal.append(0)
            
    return buy_price, sell_price, st_signal

buy_price, sell_price, st_signal = implement_st_strategy(tsla['Close'], tsla['st'])

# SUPERTREND SIGNALS

plt.plot(tsla['Close'], linewidth = 2)
plt.plot(tsla['st'], color = 'green', linewidth = 2, label = 'ST UPTREND')
plt.plot(tsla['st_dt'], color = 'r', linewidth = 2, label = 'ST DOWNTREND')
plt.plot(tsla.index, buy_price, marker = '^', color = 'green', markersize = 12, linewidth = 0, label = 'BUY SIGNAL')
plt.plot(tsla.index, sell_price, marker = 'v', color = 'r', markersize = 12, linewidth = 0, label = 'SELL SIGNAL')
plt.title('TSLA ST TRADING SIGNALS')
plt.legend(loc = 'upper left')
plt.show()
# GENERATING STOCK POSITION
position = []
for i in range(len(st_signal)):
    if st_signal[i] > 1:
        position.append(0)
    else:
        position.append(1)
        
for i in range(len(tsla['Close'])):
    if st_signal[i] == 1:
        position[i] = 1
    elif st_signal[i] == -1:
        position[i] = 0
    else:
        position[i] = position[i-1]
        
close_price = tsla['Close']
st = tsla['st']
st_signal = pd.DataFrame(st_signal).rename(columns = {0:'st_signal'}).set_index(tsla.index)
position = pd.DataFrame(position).rename(columns = {0:'st_position'}).set_index(tsla.index)

frames = [close_price, st, st_signal, position]
strategy = pd.concat(frames, join = 'inner', axis = 1)

strategy.head()
print(strategy[20:25])
# BACKTESTING
tsla_ret = pd.DataFrame(np.diff(tsla['Close'])).rename(columns = {0:'returns'})
st_strategy_ret = []

for i in range(len(tsla_ret)):
    returns = tsla_ret['returns'].iloc[i]*strategy['st_position'].iloc[i]
    st_strategy_ret.append(returns)
    
st_strategy_ret_df = pd.DataFrame(st_strategy_ret).rename(columns = {0:'st_returns'})
# First, define number_of_stocks before using it
investment_value = 100000  # Define investment_value first
# Assuming st_strategy_ret_df['st_returns'] exists and you have the stock price
# You need to define the stock price to calculate number_of_stocks
stock_price = st_strategy_ret_df['Close'].iloc[-1]  # Assuming you have a 'Close' column
number_of_stocks = floor(investment_value/stock_price)

# Now use number_of_stocks
st_investment_ret = []
for i in range(len(st_strategy_ret_df['st_returns'])):
    returns = number_of_stocks*st_strategy_ret_df['st_returns'].iloc[i]
    st_investment_ret.append(returns)

st_investment_ret_df = pd.DataFrame(st_investment_ret).rename(columns = {0:'investment_returns'})
total_investment_ret = round(sum(st_investment_ret_df['investment_returns']), 2)
profit_percentage = floor((total_investment_ret/investment_value)*100)
print(cl('Profit gained from the ST strategy by investing $100k in TSLA : {}'.format(total_investment_ret), attrs = ['bold']))
print(cl('Profit percentage of the ST strategy : {}%'.format(profit_percentage), attrs = ['bold']))

# SPY ETF COMPARISON
# This part seems to be a function definition for get_benchmark
import pandas as pd
import yfinance as yf
import numpy as np
from datetime import datetime, timedelta
from math import floor
from termcolor import colored as cl

# Define the get_historical_data function
def get_historical_data(ticker, start_date):
    # Using yfinance to get historical data
    data = yf.download(ticker, start=start_date)
    # Check if 'Close' column exists in the data
    if 'Close' not in data.columns:
        print(f"No 'Close' data available for {ticker}. Available columns: {data.columns.tolist()}")
        return None
    return data

# SPY ETF COMPARISON
def get_benchmark(start_date, investment_value):
    # Get SPY data
    spy_data = yf.download('SPY', start=start_date)
    
    # Try to find an appropriate price column
    if 'Close' in spy_data.columns:
        spy = spy_data['Close']
    elif 'Adj Close' in spy_data.columns:
        spy = spy_data['Adj Close']
        print("Using 'Adj Close' column instead of 'Close'")
    else:
        # If none of the expected columns exist, use the first numeric column
        numeric_cols = spy_data.select_dtypes(include=[np.number]).columns
        if len(numeric_cols) > 0:
            spy = spy_data[numeric_cols[0]]
            print(f"Using '{numeric_cols[0]}' column instead of 'Close'")
        else:
            print("No suitable price column found in the data")
            return pd.DataFrame()
    
    # Create benchmark returns DataFrame
    benchmark = pd.DataFrame(np.diff(spy)).rename(columns = {0:'benchmark_returns'})
    
    investment_value = investment_value
    number_of_stocks = floor(investment_value/spy.iloc[-1])  # Using iloc for safer indexing
    benchmark_investment_ret = []
    
    for i in range(len(benchmark['benchmark_returns'])):
        returns = number_of_stocks*benchmark['benchmark_returns'][i]
        benchmark_investment_ret.append(returns)

    benchmark_investment_ret_df = pd.DataFrame(benchmark_investment_ret).rename(columns = {0:'investment_returns'})
    return benchmark_investment_ret_df

# Define profit_percentage before using it
profit_percentage = 0  # Replace with your actual calculation

# Get benchmark data
benchmark = get_benchmark('2020-01-01', 100000)

# Only proceed if benchmark data was retrieved successfully
if not benchmark.empty:
    investment_value = 100000
    total_benchmark_investment_ret = round(sum(benchmark['investment_returns']), 2)
    benchmark_profit_percentage = floor((total_benchmark_investment_ret/investment_value)*100)
    print(cl('Benchmark profit by investing $100k : {}'.format(total_benchmark_investment_ret), attrs = ['bold']))
    print(cl('Benchmark Profit percentage : {}%'.format(benchmark_profit_percentage), attrs = ['bold']))
    
    # Note: Make sure profit_percentage is defined before this line
    print(cl('ST Strategy profit is {}% higher than the Benchmark Profit'.format(profit_percentage - benchmark_profit_percentage), attrs = ['bold']))